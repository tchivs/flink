<table class="configuration table table-bordered">
    <thead>
        <tr>
            <th class="text-left" style="width: 20%">Key</th>
            <th class="text-left" style="width: 15%">Default</th>
            <th class="text-left" style="width: 10%">Type</th>
            <th class="text-left" style="width: 55%">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><h5>taskmanager.runtime.aggregation.global.buffer-size</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>MemorySize</td>
            <td>Maximum size of the buffer used by Global Aggregation.The buffer holds records for aggregation in memory and is flushed to state on: 1) checkpoints, 2) watermarks, or 3) when it is full.If it's too big, and watermarks are not progressing and/or the window is big enough, there will be too much work to be done during the checkpoint sync phase.That might lead to checkpoint timeouts. If it's too small, aggregation efficiency will be lower.</td>
        </tr>
        <tr>
            <td><h5>taskmanager.runtime.aggregation.global.max-buffered-records</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>Integer</td>
            <td>Maximum number of records to buffer in Global Aggregation.see taskmanager.runtime.aggregation.global.buffer-size for more details.</td>
        </tr>
        <tr>
            <td><h5>taskmanager.runtime.hashjoin-bloom-filters</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Flag to activate/deactivate bloom filters in the hybrid hash join implementation. In cases where the hash join needs to spill to disk (datasets larger than the reserved fraction of memory), these bloom filters can greatly reduce the number of spilled records, at the cost some CPU cycles.</td>
        </tr>
        <tr>
            <td><h5>taskmanager.runtime.large-record-handler</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to use the LargeRecordHandler when spilling. If a record will not fit into the sorting buffer. The record will be spilled on disk and the sorting will continue with only the key. The record itself will be read afterwards when merging.</td>
        </tr>
        <tr>
            <td><h5>taskmanager.runtime.max-fan</h5></td>
            <td style="word-wrap: break-word;">128</td>
            <td>Integer</td>
            <td>The maximal fan-in for external merge joins and fan-out for spilling hash tables. Limits the number of file handles per operator, but may cause intermediate merging/partitioning, if set too small.</td>
        </tr>
        <tr>
            <td><h5>taskmanager.runtime.sort-spilling-threshold</h5></td>
            <td style="word-wrap: break-word;">0.8</td>
            <td>Float</td>
            <td>A sort operation starts spilling when this fraction of its memory budget is full.</td>
        </tr>
    </tbody>
</table>
